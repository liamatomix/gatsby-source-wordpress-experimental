"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.fetchAndCreateAllNodes = exports.fetchWPGQLContentNodesByContentType = exports.getGatsbyNodeTypeNames = exports.getContentTypeQueryInfos = exports.fetchWPGQLContentNodes = void 0;

require("source-map-support/register");

var _createNodes = require("../create-nodes/create-nodes");

var _fetchNodesPaginated = require("./fetch-nodes-paginated");

var _formatLogMessage = require("../../../utils/format-log-message");

var _constants = require("../../../constants");

var _store = _interopRequireDefault(require("../../../store"));

var _getGatsbyApi = require("../../../utils/get-gatsby-api");

var _chunk = _interopRequireDefault(require("lodash/chunk"));

/**
 * fetchWPGQLContentNodes
 *
 * fetches and paginates remote nodes by post type while reporting progress
 */
const fetchWPGQLContentNodes = async ({
  queryInfo
}) => {
  const {
    pluginOptions,
    helpers
  } = _store.default.getState().gatsbyApi;

  const {
    reporter
  } = helpers;
  const {
    url,
    verbose,
    schema: {
      perPage
    }
  } = pluginOptions;
  const {
    nodeListQueries,
    typeInfo,
    settings
  } = queryInfo;
  const typeName = typeInfo.nodesTypeName;

  _store.default.dispatch.logger.createActivityTimer({
    typeName,
    pluginOptions,
    reporter
  });

  let allNodesOfContentType = []; // there's normally just one query here, but more can be added using the settings.nodeListQueries api

  for (const nodeListQuery of nodeListQueries) {
    let contentNodes = await (0, _fetchNodesPaginated.paginatedWpNodeFetch)({
      first: perPage,
      after: null,
      contentTypePlural: typeInfo.pluralName,
      nodeTypeName: typeInfo.nodesTypeName,
      query: nodeListQuery,
      url,
      settings,
      helpers
    });
    allNodesOfContentType = [...allNodesOfContentType, ...contentNodes];
  }

  _store.default.dispatch.logger.stopActivityTimer({
    typeName
  });

  if (allNodesOfContentType && allNodesOfContentType.length) {
    return {
      singular: queryInfo.typeInfo.singularName,
      plural: queryInfo.typeInfo.pluralName,
      allNodesOfContentType
    };
  }

  return false;
};
/**
 * getContentTypeQueryInfos
 *
 * returns query infos (Type info & GQL query strings) filtered to
 * remove types that are excluded in the plugin options
 *
 * @returns {Array} Type info & GQL query strings
 */


exports.fetchWPGQLContentNodes = fetchWPGQLContentNodes;

const getContentTypeQueryInfos = () => {
  const {
    nodeQueries
  } = _store.default.getState().remoteSchema;

  const queryInfos = Object.values(nodeQueries).filter(({
    settings
  }) => !settings.exclude);
  return queryInfos;
};

exports.getContentTypeQueryInfos = getContentTypeQueryInfos;

const getGatsbyNodeTypeNames = () => getContentTypeQueryInfos().map(query => query.typeInfo.nodesTypeName);
/**
 * fetchWPGQLContentNodesByContentType
 *
 * fetches nodes from the remote WPGQL server and groups them by post type
 *
 * @returns {Array}
 */


exports.getGatsbyNodeTypeNames = getGatsbyNodeTypeNames;

const fetchWPGQLContentNodesByContentType = async () => {
  const contentNodeGroups = [];
  const nodeQueries = getContentTypeQueryInfos();
  const chunkSize = process.env.GATSBY_CONCURRENT_DOWNLOAD || 50;
  const chunkedQueries = (0, _chunk.default)(nodeQueries, chunkSize);

  for (const queries of chunkedQueries) {
    await Promise.all(queries.map(async queryInfo => {
      if ( // if the type settings call for lazyNodes, don't fetch them upfront here
      queryInfo.settings.lazyNodes || // if this is a media item and the nodes aren't lazy, we only want to fetch referenced nodes, so we don't fetch all of them here.
      !queryInfo.settings.lazyNodes && queryInfo.typeInfo.nodesTypeName === `MediaItem`) {
        return;
      }

      const contentNodeGroup = await fetchWPGQLContentNodes({
        queryInfo
      });

      if (contentNodeGroup) {
        contentNodeGroups.push(contentNodeGroup);
      }
    }));
  }

  return contentNodeGroups;
};
/**
 * fetchAndCreateAllNodes
 *
 * uses query info (generated from introspection in onPreBootstrap) to
 * fetch and create Gatsby nodes from any lists of nodes in the remote schema
 */


exports.fetchWPGQLContentNodesByContentType = fetchWPGQLContentNodesByContentType;

const fetchAndCreateAllNodes = async () => {
  const {
    helpers
  } = (0, _getGatsbyApi.getGatsbyApi)();
  const {
    reporter,
    cache
  } = helpers; //
  // fetch nodes from WPGQL

  const activity = reporter.activityTimer((0, _formatLogMessage.formatLogMessage)(`fetching nodes`));
  activity.start();

  _store.default.subscribe(() => {
    activity.setStatus(`${_store.default.getState().logger.entityCount} total`);
  });

  const wpgqlNodesByContentType = await fetchWPGQLContentNodesByContentType();
  const createNodesActivity = reporter.activityTimer((0, _formatLogMessage.formatLogMessage)(`creating nodes`));
  createNodesActivity.start(); //
  // Create Gatsby nodes from WPGQL response

  const createdNodeIds = await (0, _createNodes.createGatsbyNodesFromWPGQLContentNodes)({
    wpgqlNodesByContentType,
    createNodesActivity
  });
  createNodesActivity.end();
  activity.end(); // save the node id's so we can touch them on the next build
  // so that we don't have to refetch all nodes

  await cache.set(_constants.CREATED_NODE_IDS, createdNodeIds);
};

exports.fetchAndCreateAllNodes = fetchAndCreateAllNodes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdGVwcy9zb3VyY2Utbm9kZXMvZmV0Y2gtbm9kZXMvZmV0Y2gtbm9kZXMuanMiXSwibmFtZXMiOlsiZmV0Y2hXUEdRTENvbnRlbnROb2RlcyIsInF1ZXJ5SW5mbyIsInBsdWdpbk9wdGlvbnMiLCJoZWxwZXJzIiwic3RvcmUiLCJnZXRTdGF0ZSIsImdhdHNieUFwaSIsInJlcG9ydGVyIiwidXJsIiwidmVyYm9zZSIsInNjaGVtYSIsInBlclBhZ2UiLCJub2RlTGlzdFF1ZXJpZXMiLCJ0eXBlSW5mbyIsInNldHRpbmdzIiwidHlwZU5hbWUiLCJub2Rlc1R5cGVOYW1lIiwiZGlzcGF0Y2giLCJsb2dnZXIiLCJjcmVhdGVBY3Rpdml0eVRpbWVyIiwiYWxsTm9kZXNPZkNvbnRlbnRUeXBlIiwibm9kZUxpc3RRdWVyeSIsImNvbnRlbnROb2RlcyIsImZpcnN0IiwiYWZ0ZXIiLCJjb250ZW50VHlwZVBsdXJhbCIsInBsdXJhbE5hbWUiLCJub2RlVHlwZU5hbWUiLCJxdWVyeSIsInN0b3BBY3Rpdml0eVRpbWVyIiwibGVuZ3RoIiwic2luZ3VsYXIiLCJzaW5ndWxhck5hbWUiLCJwbHVyYWwiLCJnZXRDb250ZW50VHlwZVF1ZXJ5SW5mb3MiLCJub2RlUXVlcmllcyIsInJlbW90ZVNjaGVtYSIsInF1ZXJ5SW5mb3MiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJleGNsdWRlIiwiZ2V0R2F0c2J5Tm9kZVR5cGVOYW1lcyIsIm1hcCIsImZldGNoV1BHUUxDb250ZW50Tm9kZXNCeUNvbnRlbnRUeXBlIiwiY29udGVudE5vZGVHcm91cHMiLCJjaHVua1NpemUiLCJwcm9jZXNzIiwiZW52IiwiR0FUU0JZX0NPTkNVUlJFTlRfRE9XTkxPQUQiLCJjaHVua2VkUXVlcmllcyIsInF1ZXJpZXMiLCJQcm9taXNlIiwiYWxsIiwibGF6eU5vZGVzIiwiY29udGVudE5vZGVHcm91cCIsInB1c2giLCJmZXRjaEFuZENyZWF0ZUFsbE5vZGVzIiwiY2FjaGUiLCJhY3Rpdml0eSIsImFjdGl2aXR5VGltZXIiLCJzdGFydCIsInN1YnNjcmliZSIsInNldFN0YXR1cyIsImVudGl0eUNvdW50Iiwid3BncWxOb2Rlc0J5Q29udGVudFR5cGUiLCJjcmVhdGVOb2Rlc0FjdGl2aXR5IiwiY3JlYXRlZE5vZGVJZHMiLCJlbmQiLCJzZXQiLCJDUkVBVEVEX05PREVfSURTIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7QUFLTyxNQUFNQSxzQkFBc0IsR0FBRyxPQUFPO0FBQUVDLEVBQUFBO0FBQUYsQ0FBUCxLQUF5QjtBQUM3RCxRQUFNO0FBQUVDLElBQUFBLGFBQUY7QUFBaUJDLElBQUFBO0FBQWpCLE1BQTZCQyxlQUFNQyxRQUFOLEdBQWlCQyxTQUFwRDs7QUFDQSxRQUFNO0FBQUVDLElBQUFBO0FBQUYsTUFBZUosT0FBckI7QUFDQSxRQUFNO0FBQ0pLLElBQUFBLEdBREk7QUFFSkMsSUFBQUEsT0FGSTtBQUdKQyxJQUFBQSxNQUFNLEVBQUU7QUFBRUMsTUFBQUE7QUFBRjtBQUhKLE1BSUZULGFBSko7QUFNQSxRQUFNO0FBQUVVLElBQUFBLGVBQUY7QUFBbUJDLElBQUFBLFFBQW5CO0FBQTZCQyxJQUFBQTtBQUE3QixNQUEwQ2IsU0FBaEQ7QUFFQSxRQUFNYyxRQUFRLEdBQUdGLFFBQVEsQ0FBQ0csYUFBMUI7O0FBRUFaLGlCQUFNYSxRQUFOLENBQWVDLE1BQWYsQ0FBc0JDLG1CQUF0QixDQUEwQztBQUN4Q0osSUFBQUEsUUFEd0M7QUFFeENiLElBQUFBLGFBRndDO0FBR3hDSyxJQUFBQTtBQUh3QyxHQUExQzs7QUFNQSxNQUFJYSxxQkFBcUIsR0FBRyxFQUE1QixDQW5CNkQsQ0FxQjdEOztBQUNBLE9BQUssTUFBTUMsYUFBWCxJQUE0QlQsZUFBNUIsRUFBNkM7QUFDM0MsUUFBSVUsWUFBWSxHQUFHLE1BQU0sK0NBQXFCO0FBQzVDQyxNQUFBQSxLQUFLLEVBQUVaLE9BRHFDO0FBRTVD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QUFDQTs7QUFDQSxRQUFNd0QsUUFBUSxHQUFHcEQsUUFBUSxDQUFDcUQsYUFBVCxDQUF1Qix3Q0FBa0IsZ0JBQWxCLENBQXZCLENBQWpCO0FBQ0FELEVBQUFBLFFBQVEsQ0FBQ0UsS0FBVDs7QUFFQXpELGlCQUFNMEQsU0FBTixDQUFnQixNQUFNO0FBQ3BCSCxJQUFBQSxRQUFRLENBQUNJLFNBQVQsQ0FBb0IsR0FBRTNELGVBQU1DLFFBQU4sR0FBaUJhLE1BQWpCLENBQXdCOEMsV0FBWSxRQUExRDtBQUNELEdBRkQ7O0FBSUEsUUFBTUMsdUJBQXVCLEdBQUcsTUFBTXJCLG1DQUFtQyxFQUF6RTtBQUVBLFFBQU1zQixtQkFBbUIsR0FBRzNELFFBQVEsQ0FBQ3FELGFBQVQsQ0FDMUIsd0NBQWtCLGdCQUFsQixDQUQwQixDQUE1QjtBQUdBTSxFQUFBQSxtQkFBbUIsQ0FBQ0wsS0FBcEIsR0FsQmdELENBb0JoRDtBQUNBOztBQUNBLFFBQU1NLGNBQWMsR0FBRyxNQUFNLHlEQUF1QztBQUNsRUYsSUFBQUEsdUJBRGtFO0FBRWxFQyxJQUFBQTtBQUZrRSxHQUF2QyxDQUE3QjtBQUtBQSxFQUFBQSxtQkFBbUIsQ0FBQ0UsR0FBcEI7QUFDQVQsRUFBQUEsUUFBUSxDQUFDUyxHQUFULEdBNUJnRCxDQThCaEQ7QUFDQTs7QUFDQSxRQUFNVixLQUFLLENBQUNXLEdBQU4sQ0FBVUMsMkJBQVYsRUFBNEJILGNBQTVCLENBQU47QUFDRCxDQWpDTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUdhdHNieU5vZGVzRnJvbVdQR1FMQ29udGVudE5vZGVzIH0gZnJvbSBcIi4uL2NyZWF0ZS1ub2Rlcy9jcmVhdGUtbm9kZXNcIlxuaW1wb3J0IHsgcGFnaW5hdGVkV3BOb2RlRmV0Y2ggfSBmcm9tIFwiLi9mZXRjaC1ub2Rlcy1wYWdpbmF0ZWRcIlxuaW1wb3J0IHsgZm9ybWF0TG9nTWVzc2FnZSB9IGZyb20gXCJ+L3V0aWxzL2Zvcm1hdC1sb2ctbWVzc2FnZVwiXG5pbXBvcnQgeyBDUkVBVEVEX05PREVfSURTIH0gZnJvbSBcIn4vY29uc3RhbnRzXCJcbmltcG9ydCBzdG9yZSBmcm9tIFwifi9zdG9yZVwiXG5pbXBvcnQgeyBnZXRHYXRzYnlBcGkgfSBmcm9tIFwifi91dGlscy9nZXQtZ2F0c2J5LWFwaVwiXG5pbXBvcnQgY2h1bmsgZnJvbSBcImxvZGFzaC9jaHVua1wiXG5cbi8qKlxuICogZmV0Y2hXUEdRTENvbnRlbnROb2Rlc1xuICpcbiAqIGZldGNoZXMgYW5kIHBhZ2luYXRlcyByZW1vdGUgbm9kZXMgYnkgcG9zdCB0eXBlIHdoaWxlIHJlcG9ydGluZyBwcm9ncmVzc1xuICovXG5leHBvcnQgY29uc3QgZmV0Y2hXUEdRTENvbnRlbnROb2RlcyA9IGFzeW5jICh7IHF1ZXJ5SW5mbyB9KSA9PiB7XG4gIGNvbnN0IHsgcGx1Z2luT3B0aW9ucywgaGVscGVycyB9ID0gc3RvcmUuZ2V0U3RhdGUoKS5nYXRzYnlBcGlcbiAgY29uc3QgeyByZXBvcnRlciB9ID0gaGVscGVyc1xuICBjb25zdCB7XG4gICAgdXJsLFxuICAgIHZlcmJvc2UsXG4gICAgc2NoZW1hOiB7IHBlclBhZ2UgfSxcbiAgfSA9IHBsdWdpbk9wdGlvbnNcblxuICBjb25zdCB7IG5vZGVMaXN0UXVlcmllcywgdHlwZUluZm8sIHNldHRpbmdzIH0gPSBxdWVyeUluZm9cblxuICBjb25zdCB0eXBlTmFtZSA9IHR5cGVJbmZvLm5vZGVzVHlwZU5hbWVcblxuICBzdG9yZS5kaXNwYXRjaC5sb2dnZXIuY3JlYXRlQWN0aXZpdHlUaW1lcih7XG4gICAgdHlwZU5hbWUsXG4gICAgcGx1Z2luT3B0aW9ucyxcbiAgICByZXBvcnRlcixcbiAgfSlcblxuICBsZXQgYWxsTm9kZXNPZkNvbnRlbnRUeXBlID0gW11cblxuICAvLyB0aGVyZSdzIG5vcm1hbGx5IGp1c3Qgb25lIHF1ZXJ5IGhlcmUsIGJ1dCBtb3JlIGNhbiBiZSBhZGRlZCB1c2luZyB0aGUgc2V0dGluZ3Mubm9kZUxpc3RRdWVyaWVzIGFwaVxuICBmb3IgKGNvbnN0IG5vZGVMaXN0UXVlcnkgb2Ygbm9kZUxpc3RRdWVyaWVzKSB7XG4gICAgbGV0IGNvbnRlbnROb2RlcyA9IGF3YWl0IHBhZ2luYXRlZFdwTm9kZUZldGNoKHtcbiAgICAgIGZpcnN0OiBwZXJQYWdlLFxuICAgICAgYWZ0ZXI6IG51bGwsXG4gICAgICBjb250ZW50VHlwZVBsdXJhbDogdHlwZUluZm8ucGx1cmFsTmFtZSxcbiAgICAgIG5vZGVUeXBlTmFtZTogdHlwZUluZm8ubm9kZXNUeXBlTmFtZSxcbiAgICAgIHF1ZXJ5OiBub2RlTGlzdFF1ZXJ5LFxuICAgICAgdXJsLFxuICAgICAgc2V0dGluZ3MsXG4gICAgICBoZWxwZXJzLFxuICAgIH0pXG5cbiAgICBhbGxOb2Rlc09mQ29udGVudFR5cGUgPSBbLi4uYWxsTm9kZXNPZkNvbnRlbnRUeXBlLCAuLi5jb250ZW50Tm9kZXNdXG4gIH1cblxuICBzdG9yZS5kaXNwYXRjaC5sb2dnZXIuc3RvcEFjdGl2aXR5VGltZXIoeyB0eXBlTmFtZSB9KVxuXG4gIGlmIChhbGxOb2Rlc09mQ29udGVudFR5cGUgJiYgYWxsTm9kZXNPZkNvbnRlbnRUeXBlLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaW5ndWxhcjogcXVlcnlJbmZvLnR5cGVJbmZvLnNpbmd1bGFyTmFtZSxcbiAgICAgIHBsdXJhbDogcXVlcnlJbmZvLnR5cGVJbmZvLnBsdXJhbE5hbWUsXG4gICAgICBhbGxOb2Rlc09mQ29udGVudFR5cGUsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogZ2V0Q29udGVudFR5cGVRdWVyeUluZm9zXG4gKlxuICogcmV0dXJucyBxdWVyeSBpbmZvcyAoVHlwZSBpbmZvICYgR1FMIHF1ZXJ5IHN0cmluZ3MpIGZpbHRlcmVkIHRvXG4gKiByZW1vdmUgdHlwZXMgdGhhdCBhcmUgZXhjbHVkZWQgaW4gdGhlIHBsdWdpbiBvcHRpb25zXG4gKlxuICogQHJldHVybnMge0FycmF5fSBUeXBlIGluZm8gJiBHUUwgcXVlcnkgc3RyaW5nc1xuICovXG5leHBvcnQgY29uc3QgZ2V0Q29udGVudFR5cGVRdWVyeUluZm9zID0gKCkgPT4ge1xuICBjb25zdCB7IG5vZGVRdWVyaWVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpLnJlbW90ZVNjaGVtYVxuICBjb25zdCBxdWVyeUluZm9zID0gT2JqZWN0LnZhbHVlcyhub2RlUXVlcmllcykuZmlsdGVyKFxuICAgICh7IHNldHRpbmdzIH0pID0+ICFzZXR0aW5ncy5leGNsdWRlXG4gIClcbiAgcmV0dXJuIHF1ZXJ5SW5mb3Ncbn1cblxuZXhwb3J0IGNvbnN0IGdldEdhdHNieU5vZGVUeXBlTmFtZXMgPSAoKSA9PlxuICBnZXRDb250ZW50VHlwZVF1ZXJ5SW5mb3MoKS5tYXAoKHF1ZXJ5KSA9PiBxdWVyeS50eXBlSW5mby5ub2Rlc1R5cGVOYW1lKVxuXG4vKipcbiAqIGZldGNoV1BHUUxDb250ZW50Tm9kZXNCeUNvbnRlbnRUeXBlXG4gKlxuICogZmV0Y2hlcyBub2RlcyBmcm9tIHRoZSByZW1vdGUgV1BHUUwgc2VydmVyIGFuZCBncm91cHMgdGhlbSBieSBwb3N0IHR5cGVcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaFdQR1FMQ29udGVudE5vZGVzQnlDb250ZW50VHlwZSA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgY29udGVudE5vZGVHcm91cHMgPSBbXVxuXG4gIGNvbnN0IG5vZGVRdWVyaWVzID0gZ2V0Q29udGVudFR5cGVRdWVyeUluZm9zKClcblxuICBjb25zdCBjaHVua1NpemUgPSBwcm9jZXNzLmVudi5HQVRTQllfQ09OQ1VSUkVOVF9ET1dOTE9BRCB8fCA1MFxuICBjb25zdCBjaHVua2VkUXVlcmllcyA9IGNodW5rKG5vZGVRdWVyaWVzLCBjaHVua1NpemUpXG5cbiAgZm9yIChjb25zdCBxdWVyaWVzIG9mIGNodW5rZWRRdWVyaWVzKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBxdWVyaWVzLm1hcChhc3luYyAocXVlcnlJbmZvKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBpZiB0aGUgdHlwZSBzZXR0aW5ncyBjYWxsIGZvciBsYXp5Tm9kZXMsIGRvbid0IGZldGNoIHRoZW0gdXBmcm9udCBoZXJlXG4gICAgICAgICAgcXVlcnlJbmZvLnNldHRpbmdzLmxhenlOb2RlcyB8fFxuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBtZWRpYSBpdGVtIGFuZCB0aGUgbm9kZXMgYXJlbid0IGxhenksIHdlIG9ubHkgd2FudCB0byBmZXRjaCByZWZlcmVuY2VkIG5vZGVzLCBzbyB3ZSBkb24ndCBmZXRjaCBhbGwgb2YgdGhlbSBoZXJlLlxuICAgICAgICAgICghcXVlcnlJbmZvLnNldHRpbmdzLmxhenlOb2RlcyAmJlxuICAgICAgICAgICAgcXVlcnlJbmZvLnR5cGVJbmZvLm5vZGVzVHlwZU5hbWUgPT09IGBNZWRpYUl0ZW1gKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnROb2RlR3JvdXAgPSBhd2FpdCBmZXRjaFdQR1FMQ29udGVudE5vZGVzKHsgcXVlcnlJbmZvIH0pXG5cbiAgICAgICAgaWYgKGNvbnRlbnROb2RlR3JvdXApIHtcbiAgICAgICAgICBjb250ZW50Tm9kZUdyb3Vwcy5wdXNoKGNvbnRlbnROb2RlR3JvdXApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnROb2RlR3JvdXBzXG59XG5cbi8qKlxuICogZmV0Y2hBbmRDcmVhdGVBbGxOb2Rlc1xuICpcbiAqIHVzZXMgcXVlcnkgaW5mbyAoZ2VuZXJhdGVkIGZyb20gaW50cm9zcGVjdGlvbiBpbiBvblByZUJvb3RzdHJhcCkgdG9cbiAqIGZldGNoIGFuZCBjcmVhdGUgR2F0c2J5IG5vZGVzIGZyb20gYW55IGxpc3RzIG9mIG5vZGVzIGluIHRoZSByZW1vdGUgc2NoZW1hXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaEFuZENyZWF0ZUFsbE5vZGVzID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7IGhlbHBlcnMgfSA9IGdldEdhdHNieUFwaSgpXG4gIGNvbnN0IHsgcmVwb3J0ZXIsIGNhY2hlIH0gPSBoZWxwZXJzXG5cbiAgLy9cbiAgLy8gZmV0Y2ggbm9kZXMgZnJvbSBXUEdRTFxuICBjb25zdCBhY3Rpdml0eSA9IHJlcG9ydGVyLmFjdGl2aXR5VGltZXIoZm9ybWF0TG9nTWVzc2FnZShgZmV0Y2hpbmcgbm9kZXNgKSlcbiAgYWN0aXZpdHkuc3RhcnQoKVxuXG4gIHN0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgYWN0aXZpdHkuc2V0U3RhdHVzKGAke3N0b3JlLmdldFN0YXRlKCkubG9nZ2VyLmVudGl0eUNvdW50fSB0b3RhbGApXG4gIH0pXG5cbiAgY29uc3Qgd3BncWxOb2Rlc0J5Q29udGVudFR5cGUgPSBhd2FpdCBmZXRjaFdQR1FMQ29udGVudE5vZGVzQnlDb250ZW50VHlwZSgpXG5cbiAgY29uc3QgY3JlYXRlTm9kZXNBY3Rpdml0eSA9IHJlcG9ydGVyLmFjdGl2aXR5VGltZXIoXG4gICAgZm9ybWF0TG9nTWVzc2FnZShgY3JlYXRpbmcgbm9kZXNgKVxuICApXG4gIGNyZWF0ZU5vZGVzQWN0aXZpdHkuc3RhcnQoKVxuXG4gIC8vXG4gIC8vIENyZWF0ZSBHYXRzYnkgbm9kZXMgZnJvbSBXUEdRTCByZXNwb25zZVxuICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IGF3YWl0IGNyZWF0ZUdhdHNieU5vZGVzRnJvbVdQR1FMQ29udGVudE5vZGVzKHtcbiAgICB3cGdxbE5vZGVzQnlDb250ZW50VHlwZSxcbiAgICBjcmVhdGVOb2Rlc0FjdGl2aXR5LFxuICB9KVxuXG4gIGNyZWF0ZU5vZGVzQWN0aXZpdHkuZW5kKClcbiAgYWN0aXZpdHkuZW5kKClcblxuICAvLyBzYXZlIHRoZSBub2RlIGlkJ3Mgc28gd2UgY2FuIHRvdWNoIHRoZW0gb24gdGhlIG5leHQgYnVpbGRcbiAgLy8gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHJlZmV0Y2ggYWxsIG5vZGVzXG4gIGF3YWl0IGNhY2hlLnNldChDUkVBVEVEX05PREVfSURTLCBjcmVhdGVkTm9kZUlkcylcbn1cbiJdfQ==